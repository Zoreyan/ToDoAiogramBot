# ToDo List с Telegram-ботом

## Описание

Проект представляет собой ToDo List с категориями и задачами, связанных с пользователями.  
Основной backend на Django + DRF, Telegram-бот на Aiogram, асинхронное выполнение задач с Celery и Redis.  
Все сервисы запускаются и взаимодействуют через Docker Compose.

---

## Требования

- Docker  
- Docker Compose

---

## Запуск проекта

1. Клонируйте репозиторий:

```bash
git clone <URL_репозитория>
cd <папка_проекта>
```
При необходимости настройте переменные окружения в .env (например, Telegram Bot Token).

Запустите все сервисы:
```bash
docker-compose up --build
```
Дождитесь запуска всех контейнеров.

Backend будет доступен по адресу: http://localhost:8000

Использование бота
Найдите вашего Telegram-бота или воспользуйтесь готовым @ToDoZ1Bot и отправьте команду /start.

Через меню добавляйте категории и задачи.

Бот отправит уведомления за 120 минут до дедлайна задачи.

Полезные команды
Остановить и удалить контейнеры:

```bash
docker-compose down
```
Просмотр логов backend:

```bash
docker-compose logs -f web
```
Просмотр логов Celery:

```bash
docker-compose logs -f celery
```
# Особенности реализации
Django использует часовой пояс America/Adak.

Для фоновых задач и уведомлений используется Celery с брокером Redis.

PK не используют UUID или стандартные автоинкременты.

API и бот связаны через REST API.

# Трудности во время разработки и как я их решил
Во время разработки я столкнулся с несколькими ключевыми трудностями:

Ограничения на типы PK
По заданию нельзя было использовать стандартные ID: UUID, автоинкременты, функции Postgres и random. Это потребовало реализации кастомной логики генерации первичных ключей, с учётом уникальности и сериализации в миграциях. Я решил это, создав функцию generate_custom_id с использованием get_random_string из django.utils.crypto, и использовал её в default вместо lambda, чтобы избежать ошибок сериализации в миграциях.

Отложенные задачи с Celery
При попытке отправки уведомлений в указанное время, Celery не выполнял задачи. Оказалось, что причина была в неверной настройке часового пояса и eta с учётом TIME_ZONE. Я исправил это, убедившись, что timezone.make_aware() применяется ко всем datetime, и Celery запускается с корректной переменной окружения.

Контейнеры Docker не могли "увидеть" друг друга
Aiogram-бот внутри Docker-контейнера не мог обратиться к Django по localhost, потому что в сети Docker это имя означает сам контейнер. Проблема решена указанием имени Django-сервиса (web, например) как хоста в URL API-запросов.

Ограничение Telegram по длине текста
При выводе списка задач возникала ошибка TelegramBadRequest: text is too long. Я реализовал разбиение длинного текста на части и отправку их по отдельности.

Сложность в работе с FSM и управлением состоянием в Aiogram
Чтобы улучшить UX, я внедрил FSM для поэтапного создания задач и категорий. Это помогло избежать путаницы в данных и улучшило читаемость кода.

Аутентификация пользователей без логина и пароля
Я долго не мог понять, как реализовать авторизацию, если пользователь взаимодействует только через Telegram. В итоге решил использовать telegram_id как способ идентификации. Создал эндпоинт, который создаёт или возвращает пользователя по telegram_id, без пароля, с использованием set_unusable_password(). Это позволило упростить весь процесс взаимодействия между ботом и бэкендом.

Инкрементируемые inline-кнопки и их callback_data
Aiogram не сразу позволил удобно организовать работу с inline_keyboard, особенно когда нужно было динамически добавлять кнопки с уникальными callback_data и потом правильно их обрабатывать. Поначалу возникал беспорядок: все кнопки отображались в один ряд или обработчики не срабатывали.
Я разобрался, как правильно формировать InlineKeyboardMarkup с помощью вложенных списков ([[button]]), корректно обрабатывать callback_query, а также безопасно извлекать id из callback_data. В дальнейшем это позволило сделать интерфейс пользователя гораздо удобнее.

По факту проблем и трудностей было много,но они мелочные и только нагрузили бы этот README.
Это ТЗ познакомило меня с новыми возможностьями Celery и Aiogram. Было настолько интересно делать его что я целую ночь не спал пытаясь исправлять баги. Задание не сложное, на 5-6 часов если знать необходимые технологии, но мне пришлось по ходу обучаться, потому что ранее я с такими задачами не сталкивался.
